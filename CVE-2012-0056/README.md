# CVE-2012-0056 



## 0x00漏洞简介
https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-0056

Linux通过一个特殊字符设备/proc/$pid/mem把每个进程的虚拟内存暴露为一个文件.出于安全考虑,读写这个文件的权限被严格限制,拥有写入权限的只有内存的所属进程.但是攻击者可以打开目标进程的mem设备,把它复制到进程的stdout和stderr.当stdout重定向到与虚拟内存相关的字符设备时,攻击者可以写入其他程序内存,但是写入的地址是未知的.

用法：
需要shell权限，exit（）位于0xd7f4，对sysresuid（）的调用位于0xad4b
Useage：
$ ./mempodroid 0xd7f4 0xad4b mount -o remount,rw '' /system
$ ./mempodroid 0xd7f4 0xad4b sh
# 

## 0x01漏洞补丁
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e268337dfe26dfc7efd422a804dbb27977a3cccc

```
//open /proc/pid/mem
static int mem_open(struct inode* inode, struct file* file)
{
	file->private_data = (void*)((long)current->self_exec_id);
	file->f_mode |= FMODE_UNSIGNED_OFFSET;
	return 0;
}
 

```
系统会检查打开/poc/$pid/mem的程序的self_exec_id是否与当前运行的程序相同,一个进程使用exec()后self_exec_id会自动加一,以此来保护内存不会被别的程序修改.

```
static ssize_t mem_write(struct file * file, const char __user *buf,
             size_t count, loff_t *ppos)
{

/* unimportant code removed for blog post */

    struct task_struct *task = get_proc_task(file-&gt;f_path.dentry-&gt;d_inode);

/* unimportant code removed for blog post */

    mm = check_mem_permission(task);//第一次检查
    copied = PTR_ERR(mm);
    if (IS_ERR(mm))
        goto out_free;

/* unimportant code removed for blog post */

    if (file-&gt;private_data != (void *)((long)current-&gt;self_exec_id))//第二次检查
        goto out_mm;

/* unimportant code removed for blog post
 * (the function here goes onto write the buffer into the memory)
 */
```

The code of check_mem_permission simply calls into __check_mem_permission

```
static struct mm_struct *__check_mem_permission(struct task_struct *task)
{
    struct mm_struct *mm;

    mm = get_task_mm(task);
    if (!mm)
        return ERR_PTR(-EINVAL);

    /*
     * A task can always look at itself, in case it chooses
     * to use system calls instead of load instructions.
     */
    if (task == current)
        return mm;

    /*
     * If current is actively ptrace'ing, and would also be
     * permitted to freshly attach with ptrace now, permit it.
     */
    if (task_is_stopped_or_traced(task)) {
        int match;
        rcu_read_lock();
        match = (ptrace_parent(task) == current);
        rcu_read_unlock();
        if (match &amp;&amp; ptrace_may_access(task, PTRACE_MODE_ATTACH))
            return mm;
    }

    /*
     * No one else is allowed.
     */
    mmput(mm);
    return ERR_PTR(-EPERM);
}
```


## 如何根据漏洞编号去查commit???

